생성자 심화

생성자는 메소드와 동일한데 주소값을 반환할 뿐이다.
그렇기 때문에 오버로딩이 된다.(메소드 이기에)

기본 생성자는 애초에 생략이 되어 있다.
생성자의 오버로딩이 이루어지면 기본 생성자는 생략되어있던 것이 비활성화가 된다.(오버로딩 된 애들이 덮어쓰기하는 것)
그렇기 때문에 기본생성자를 사용하기 위해서는 기본생성자를 만들어야한다.

다른 생성자가 없다면 기본생성자가 생략되어도 무관하다.

생성자를 통해서 오버로딩을 하는 이유

클래스에 지정되는 변수 : 멤버변수, 참조변수, 레퍼런스 변수 라고 불린다.

클래스에는 변수, 메소드가 존재하는데
메소드의 매개변수와 클래스내의 멤버변수의 명이 같을 수 있다.
본래라면 허용이 되지 않는데 클래스내에서는 이를 허용하면서 둘을 다르게 본다.

이 때 생성자가 생성될 당시에 매개변수를 받을 때 그 매개변수를 클래스의 멤버변수에
대입을 하고 싶을 때 
받고자하는 생성자 실행부에 this.멤버변수 = 매개변수; 로 표현해서 대입할 수 있다.
우선순위는 지역변수가 높다.

여기서 this. 이라는 것은 . 즉 참조한다 주소값을 찾아간다라는 의미이고 this는 자기자신을
의미하는데 여기서 자기자신이란 class를 뜻한다. 이 말을 풀어보면 클래스의 주소값에 들어가서
뒤의 멤버변수를 찾아라 라는 의미이다.
===========================================================================

접근지정자 : 클래스의 멤버 각각에 외부에서 접근할 수 있는 범위

자바 접근지정자 종류
public  : 제한없음
protected : 동일 패키지, 상속 받은 클래스 내부
default :  동일 패키지
private : 동일 클래스

접근 + 지정자

접근은 참조를 한다라는 의미
지정은 그 범위를 지정한다라는 의미

데이터는 항상 메소드를 통해 들고온다
멤버변수 들은 항상 private로 막는다.(데이터의 은닉)

메소드는 연결하기 위한 창구 같은 존재인데 
클래스내에서만 작동이 되야하는 메소드들은 멤버변수 처럼 private로 막아둔다.

예를 들어 메소드안의 기능이 중첩이 되고 방대해져서 나누어야 할 경우 그 메소드 전체가 
다른 클래스에서 쓰이지 않는 경우에 굳이 전부 오픈할 필요가 없다.

이러한 멤버변수가 private로 막아뒀을 때 정보를 들고오거나 저장할 때 쓰이는
메소드를 Getter 와 Setter라고 한다.


캡슐화


깃 과 깃헙

깃을 만든사람 리누스 토발즈

유닉스는 최초의 운영체제의 모습을 가진 운영체제 (벨연구소 IBM)
(유료 버전)

리눅스는 유닉스에 파생되서 나온 운영체제(리누스 토발즈가 만듬)
오픈소스를 사용할 수 있다. 가볍다.

리눅스를 사용하다보니 버전관리의 문제가 있었다.
내 소스 코드를 협업시 공유를 해야 했다.

이 불편한 것이 싫어서 개발한 것이
형상관리 (분산 버전 관리) 시스템 깃이다.

깃은 스냅샷 스트림 기반의 분산 버전 관리 시스템이다.

현재 상태를 사진찍듯이 찍어 시간대별로 저장하여 관리한다는 뜻



add : 파일을 스테이지에 올리는 행위 -> 아직 로컬상태

commit : 스테이지에 올린 파일을 저장하는 형태 -> 아직 로컬상태

push : 커밋된 파일을 클라우드 저장소에 올리는 형태 

		Local                                       					 | 				Remote

working directory		staging area 		local repository				remote repository
작업공간 (로컬)

			git add
				->	
						(작업 메세지포함)
							git commit
							    ->					
												git push
													->
						
												git fetch
													<-					
 
				git checkout
			<-------------------------

				git merge
			<-------------------------


head 는 임시브랜치다 그래서 head라는 브랜치일 때 커밋을 하면 안된다.


배열

배열은 참조자료형이다

배열 선언 형식 

자료형[] 변수명 = new 자료형[배열의 길이];

인덱스 값이 존재한다. 인덱스 값은 변수가 될 수 있다 인덱스 값은 정수이다. 인덱스를 참조하는 개념

모든 자료형은 배열로 만들 수 있다.

선언할 때 new 가 들어가면 동적 할당  > 참조라고 생각하면 된다. 주소값이 생성된다.

예를 들어서 변수 하나하나 프린트 하는 것은 너무 비효율적이고 반복을 하려면
반복을 할 수 있는 형태를 만들어 주면 된다. 그 형태가 배열의 형태이다.







