stateFull , **Stateless** 가장 중요한 것 서버에서 개발자들이 어려워 한다.

- 

full 은 서버가 모든정보를 저장하고 있어야한다..
그래서 만약에 서버가 장애가 일어나면 클라이언트가 처음부터 시작해야한다..

less는 정보를 저장하지 않고 애초에 클라이언트가 요청을할 때 정보를 넘겨주면서 어떤 서버에서든 처리가 가능하다.


Stateless 

실무 한계

모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.

무상태 > 로그인이 필요없는 단순한 서비스 소개화면

상태 유지 > 로그인

로그인한 사용자의 경우 로그인한 상태를 서버에 유지해야한다.

일반적으로 브라우저 쿠키와 서버세션등을 사용해서 상태유지
상태유지는 최소한만 사용!

=================================================

비연결성

연결을 유지하는 모델

클라이언트가 1/2/3이 있다고 생각을 할때 서버에 요청을 보내고 응답을 받고 계속 서버는 연결을 계속 유지하는경우
서버의 자원이 소모된다.

연결을 유지하지 않는 모델

클라이언트의 요청을하고 응답을 받은후 서버가 연결을 끊어버린다. 최소한의 자원 유지가 가능하다.

그리고 다시 클라이언트가 요청이 있어서 서버에 요청이오면 다시 연결하는 식으로 가는 원리


- Http는 기본이 연결을 유지하지 않는 모델

- 일반적으로 초 단위의 이하의 빠른 속도로 응답

- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우작다.

예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
- 서버 자원을 매우 효율적으로 사용할 수 있다.


비연결성의 한계
TCP/IP 연결을 새로 맺어야 한다. 3 way handshake 시간추가 된다.
웹브라우저로 사이트를 요청하면 HTML 뿐만아니라 자바스크립트, css ,추가 이미지등 수많은 자원이 함께 다운로드 된다.

지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
연결을 한 후에 요청과 응답을 받는데 얼마정도의 시간을 두고 그 시간동안은 연결을 유지해서 요청을 받고 응답을 주는걸 다한후에
종료를 시킨다.
HTTP/2, HTTP/3 에선 최적화가 되었다.